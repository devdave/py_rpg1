<!doctype html>
<html>
    <head>
        <title>Map prototype 1</title>
        <style>
            #canvas_map {
                border: solid thin black;
                width: 500px;
                height: 500px;
            }
            #viewport {
                border: solid thin black;
                width: 100px;
                height: 100px;
            }
        </style>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
        <script src="./p2_fake_map.js"></script>
        <script src="./map_canvas2.js"></script>
        <script src="./ping_js/ping.js"></script>

    </head>
    <body>
        <canvas id="canvas_map"></canvas>
        <canvas id="viewport"></canvas>
        <div id="controls">
            <button name="go" value="">up</button>
            <button name="go" value="">north</button>
            <button name="go" value="">down</button>
            <br>
            <button name="go" value="">west</button>
            <button name="go" value="">south</button>
            <button name="go" value="">east</button>
        </div>
    </body>


    <script>


        (function(){

            var my_map = new GameMap(fakeMap),
                canvas_map = document.getElementById("canvas_map"),
                ctx_map = canvas_map.getContext("2d"),
                canvas_view = document.getElementById("viewport"),
                ctx_view = canvas_view.getContext("2d");
                game_cols = fakeMap.cols,
                game_rows = fakeMap.rows,
                map_scalex = canvas_map.width / game_cols,
                map_scaley = canvas_map.height / game_rows,
                view_scalex = canvas_view.width / game_cols,
                view_scaley = canvas_view.height / game_rows,
                max_x = 2, max_y = 2,
                player = {

                    x: 0,
                    y: 0

                },
                update = false;
                console.log({
                    my_map: my_map,
                    canvas_map: canvas_map,
                    ctx_map: ctx_map,
                    canvas_view: canvas_view,
                    ctx_view: ctx_view,
                    game_cols: game_cols,
                    game_rows: game_rows,
                    map_scalex: map_scalex,
                    map_scaley: map_scaley,
                    view_scalex: view_scalex,
                    view_scaley: view_scaley,
                    max_x: max_x,
                    max_y: max_y,
                    player: player
                });
                ping.Lib.initInput();

                function clearView() {
                    ctx_view.beginPath();
                    ctx_view.clearAll();
                    ctx_view.closePath();
                }

                //point this in ping
                function clamp(z, min, max) {
                    if (z < min) {
                        return min;
                    } else if (z > max){
                        return max;
                    }
                    return z;
                }

                function redrawView() {
                    console.log("player", player);
                    clearView();

                    //Player should not be out of bounds
                    player.x = Math.max(0, player.x);
                    player.y = Math.max(0, player.y);
                    player.x = Math.min(game_cols-1, player.x);
                    player.y = Math.min(game_rows-1, player.y);

                    var tiles = my_map.grid.findBox({
                            x:Math.min(2, player.x),
                            y:Math.min(2, player.y),
                            sx:2,
                            sy:2
                        }),
                        vbox_width = ctx_view.canvas.width / 3,
                        vbox_height = ctx_view.canvas.height / 3;

                    console.log(tiles.length, player,
                        {
                            x:Math.min(2, player.x),
                            y:Math.min(2, player.y),
                            sx:2,
                            sy:2
                        }
                    );
                    ctx_view.save();


                    for(var i = 0; i < tiles.length; i++){
                        ctx_view.beginPath();
                        ctx_view.fillStyle = tiles[i].fillStyle;
                        ctx_view.fillRect(
                            (tiles[i].x - Math.min(2, player.x)) * vbox_width,
                            (tiles[i].y - Math.min(2, player.y)) * vbox_height,
                            vbox_width,
                            vbox_height
                        );
                        ctx_view.closePath();
                    }
                    ctx_view.restore();

                    //Draw the player now
                    var wtf = {
                        x: (player.x * vbox_width) + vbox_width/2,
                        y: (player.y * vbox_height) + vbox_height/2,
                        cw: ctx_view.canvas.width,
                        ch: ctx_view.canvas.height,
                        vw: vbox_width,
                        vh: vbox_height
                    };
                    ctx_view.save();
                    ctx_view.beginPath();
                    ctx_view.arc(
                        wtf.x,
                        wtf.y,
                        13,
                        0,
                        Math.PI * 2,
                        1
                    );
                    console.log(player, wtf);


                    ctx_view.fillStyle = "white";
                    ctx_view.fill();
                    ctx_view.restore();






                }


                function gameLoop() {
                    "use strict";
                    var tiles;

                    if (ping.Lib.Input.state.U) {
                        player.y -= 1
                        update = true;
                    }
                    else if (ping.Lib.Input.state.D) {
                        player.y += 1;
                        update = true;
                    }

                    if (ping.Lib.Input.state.L) {
                        player.x = Math.max(0, player.x -1);
                        update = true;
                    }
                    else if (ping.Lib.Input.state.R) {
                        player.x = Math.min(fakeMap.cols, player.x + 1);
                        update = true;
                    }


                    if (update) {
                        redrawView();
                        update = false;
                    }

                    setTimeout(gameLoop, 150);

                }



            my_map.render(ctx_map);
            redrawView();

            gameLoop();



        })();
    </script>


</html>
